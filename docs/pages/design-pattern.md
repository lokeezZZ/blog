---
title: 设计模式
date: 2020-05-28
categories:
 - 前端
 - 工程化
tags:
 - 基础
---

## 前言

设计模式，是开发人员在开发程序过程中面临问题所使用的一些解决方案，是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。

由于`JavaScript`不像那些强类型语言（如`Java`）是单线程弱类型语言，在前端中使用设计模式时变得简单粗暴。尽管如此，我们依然要遵守**设计模式的原则**，目的是**重用代码、让代码更容易被他人理解、保证代码可靠性**。

## 模式的起源

_[摘自网络]_

设计模式并非是软件开发中的专业术语，实际上最早诞生于建筑学。20 世纪 70 年 代，哈佛大学建筑学博士和他的研究团队花了约 20 年的时间，研究了为解决同一问题而设计出不同结构建筑，从中发现了那些高质量设计中的相似性，并且用“模式”来指代相似性。

许多程序员从设计模式中学到了设计软件的灵感，或者找到了问题的解决答案。在社区中，有人对模式充满误解。有些人却认为设计模式只在`C++`或者`Java`中使用，`Javascript`这种动态语言没有设计模式一说。

近年来，前端技术发展迅速，不再是写几个`css` 样式和绑定事件了。大部分工具库、框架都在使用设计模式。了解它不仅为我们提供如何简洁而优雅地解决问题的思路，更能理解如何更正确、高效的使用那些工具库、框架。

## 七大原则

### 1.  开闭原则

**对扩展开放，对修改关闭。** 在程序需要进行拓展时，不能去修改原有的代码，实现一个热插拔的效果。所以，也因此暴露了一个终极的问题：重构。但不用怕，`java` 中有很多优秀的架构设计如 `Spring` `Struts` `Hibernate`，经久不衰。

### 2.  里氏代换原则

**不应该通过子类重写基类的功能**。任何基类可以出现的地方，子类一定可以出现，并且程序的功能不受到影响。

例如，基类 `车` 🚗 有 `车身` 、`颜色` 2 个基本属性，`法拉利` 继承 `车` 并想新增一个 `贴纸` ，应该在 `法拉利` 中扩展该属性，而不是修改 `车` 的 `颜色` 属性。 **因此，里氏代换原则是对开闭原则的补充。**

### 3.  依赖倒转原则

**面向接口编程**。依赖倒置原则是实现开闭原则的重要途径之一，它降低了抽象与实现模块之间的耦合。

回到 `车` 🚗 这个类，如果在 `法拉利` 新增了 `贴纸` 属性，那以后就会有更多类似的属性或方法如 `喷漆`、 `打蜡` ，此时，不如抽离出抽象的 `汽车美容` ，在 `法拉利` 销售过程中，有没有 `贴纸` 就没有那么多捆绑销售了。

### 4.  单一职责原则

**一个类只负责一项功能**。如果一个对象承担了太多的职责，那么势必会造成非必要的资源占用。我还是说回 `法拉利` 🚗 吧，不要问我为什么。

如果为 `法拉利` 添加 `销售` 的功能，看起来没什么不合理，但现实生活中，`法拉利` 并不一定要 `销售`，还可以是 `展览品` ， `样品` 。所以对于 `法拉利` 来说，只有 `组装` 就好。如果不 `组装`，那他还是 `法拉利` 吗？

### 5.  接口隔离原则

**一个类对另一个类的依赖应该建立在最小的接口上。** 没有关系的接口合并在一起，形成一个臃肿的大接口，这是对实例和接口的污染。简单的理解，调用接口就是 `拼积木` 的过程，`积木` 越小，创造性就越大。

### 6.  迪米特原则

**每个类尽量减少对其他类的依赖，功能独立，相互之间不存在（或很少有）依赖关系。** 正如我们不需要知道 `法拉利` 是如何 `组装` 、`生产` 和 `运输` 一样，我们只需要关心他的 `售价`。（扎铁了老心）

### 7.  合成复用原则

**少用继承，多用合成关系来实现。** 如果用电路连接方式来解释，`继承` 是串联电路，`合成复用` 则是并联电路。其中一个灯泡熄火，串联电路必定全部熄火。

## 通过前端的角度看设计模式

以下是一个前端处理上传图片的简单示例。在某一个优化版本中，接口字段的变动都会导致前端工作量增加许多。当然，用前端代码来举例子可能不太恰当，只是为了方便大家先简单的接触。 **同时也希望大家开启思考，以后在开发时以抽象思维来写代码，转变面向过程的代码。**

`例1` 开闭原则在前端的体现

```ts
interface Response<T> {
    status: number;
    data: T
}
interface UploadResponse extends Response<string> {
    // do something...
}
// 业务代码
function handleResponse(rep: UploadResponse): Image {
    const imgEle = new Image();
    imgEle.src = rep.data;
    return imgEle;
}
// function handleResponse 2
// function handleResponse 3
// ...
```

> tips: 改动字段名或返回值都是一个很危险的行为。下次如果后端改字段的话，不要默默承受前端不该有的妥屈，直接怼后端就是了。

其实如果理解了开闭原则，其他几个原则都很好理解了，比如 "里氏代换原则是对开闭原则的补充", 因为不能对父类修改，而子类是继承父类的，所以拥有父类的所有属性和方法，那当然可以替代父类出现的地方。

`例2` 里氏代换原则

```ts
class Axios {
    public post():Promise<Response>{
        // do something..
    }
}
class MyFetch extends Axios {
    public ajax():Promise<Response>{
        // do something..
    }
}
// 业务代码
const $http = new MyFetch; // MyFetch 可以在任何时候替代 Axios
$http.post();
```

但如果你重写了 `Axios` 上的方法，那么就会破坏开闭原则。众所周知，在 javascript 中 `class` 是语法糖，经过 `Babel` 编译以后，代码是这样的:

```js
"use strict";
var Axios = function () {
  function Axios() {}
  var _proto = Axios.prototype;
  _proto.post = function post() {
      // do something..
  };
  return Axios;
}();
```

那么，如果通过 `Axios.prototype` 对原型上的方法进行修改，那就有趣了,
**你品，你细品。**

``` js
Axios.prototype.post = 'interesting';

// 业务代码
const $http = new MyFetch; // MyFetch 可以在任何时候替代 Axios
$http.post(); // Uncaught TypeError: 'post' is not a function;
```

苦心搬砖写的代码，突然就变得不可信了是吧？为什么相同的代码，在不同的项目中表现总是令人惊讶？**就是因为开发人员在开发时，没有遵守开闭原则。** 我们痛斥这类现象，同时也要自我反省。

